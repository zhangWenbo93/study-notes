(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{534:function(v,_,t){"use strict";t.r(_);var s=t(40),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"node-js在前后端的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js在前后端的区别"}},[v._v("#")]),v._v(" Node.js在前后端的区别")]),v._v(" "),t("h2",{attrs:{id:"node-js-从工程化工具到后端服务应用的转变和区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js-从工程化工具到后端服务应用的转变和区别"}},[v._v("#")]),v._v(" Node.js 从工程化工具到后端服务应用的转变和区别")]),v._v(" "),t("p",[v._v("Node.js 不仅可以用来做前端的工程化，比如：利用 webpack 提升前端开发效率以及保证开发质量、 SSR 的实现以及前端的一些工具化场景，也可以用来做部分后端开发，因为它的一些优点，比如：高并发特性以及研发高效能。")]),v._v(" "),t("p",[v._v("但其实前端应用的最终目的都是为了"),t("strong",[v._v("提升前端研发效率或者保证研发质量")]),v._v("，并没有真正的使用到 Node.js 核心特点。而后端服务应用才是真正地应用 Node.js 异步事件驱动的特性。")]),v._v(" "),t("p",[v._v("下面的会从以下几个方面分析两者的区别")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("差异点")]),v._v(" "),t("th",[v._v("说明")]),v._v(" "),t("th",[v._v("前端应用")]),v._v(" "),t("th",[v._v("后端应用")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("运行环境")]),v._v(" "),t("td",[v._v("Node.js运行在何处")]),v._v(" "),t("td",[v._v("运行在本地")]),v._v(" "),t("td",[v._v("运行在远程服务器")])]),v._v(" "),t("tr",[t("td",[v._v("受众用户")]),v._v(" "),t("td",[v._v("启用的服务，受众用户")]),v._v(" "),t("td",[v._v("服务于本地开发")]),v._v(" "),t("td",[v._v("服务真实用户")])]),v._v(" "),t("tr",[t("td",[v._v("问题调试")]),v._v(" "),t("td",[v._v("定位问题对比")]),v._v(" "),t("td",[v._v("调试简单")]),v._v(" "),t("td",[v._v("复杂，需要日志埋点")])]),v._v(" "),t("tr",[t("td",[v._v("关注点")]),v._v(" "),t("td",[v._v("着重解决的问题")]),v._v(" "),t("td",[v._v("提升研发效率、质量")]),v._v(" "),t("td",[v._v("保证安全、稳定性")])])])]),v._v(" "),t("h3",{attrs:{id:"运行环境"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行环境"}},[v._v("#")]),v._v(" 运行环境")]),v._v(" "),t("ul",[t("li",[v._v("前端工程化大部分情况都是依赖于当前开发环境，运行在本地开发机器，可以快速判断定位、分析解决问题")]),v._v(" "),t("li",[v._v("后端服务基本都是运行于远程服务器上，需要依赖于一些工具分析判断或者监控其运行情况")])]),v._v(" "),t("blockquote",[t("p",[v._v("那么因为运行环境的差异，由此会引发那些不同呢？")])]),v._v(" "),t("ul",[t("li",[v._v("需要应用工具将服务发布到远程机器上，这里就涉及 "),t("strong",[v._v("devops 工具")])]),v._v(" "),t("li",[v._v("需要保证远程服务的安全与稳定，这就涉及一些进程管理工具，例如我们常见的 "),t("strong",[v._v("PM2")])]),v._v(" "),t("li",[v._v("需要判断远程服务运行是否正常，这就涉及远程服务的"),t("strong",[v._v("监控和告警机制")])]),v._v(" "),t("li",[v._v("需要通过远程日志来定位分析问题，这就涉及日"),t("strong",[v._v("志打印和跟踪染色")])])]),v._v(" "),t("h3",{attrs:{id:"受众用户"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#受众用户"}},[v._v("#")]),v._v(" 受众用户")]),v._v(" "),t("ul",[t("li",[v._v("前端工程化一般都是服务于开发者，比如 Webpack 打包或者将 ES6、ES7 转为 ES5 语法等，都是基于开发者工具，服务于开发者")]),v._v(" "),t("li",[v._v("后端服务应用则服务于真实的用户群体，为用户提供各种交互体验方面的数据处理等")])]),v._v(" "),t("blockquote",[t("p",[v._v("那么因为受众用户的差异，由此会引发那些不同呢？")])]),v._v(" "),t("ul",[t("li",[v._v("前端工程化侧重于为开发者"),t("strong",[v._v("提升研发效率或者研发质量")])]),v._v(" "),t("li",[v._v("后端服务应用则侧重点更多，比如：\n"),t("ul",[t("li",[v._v("由于是基于用户发送的内容，用户有时候发送一些非法或者违法的内容，因此必须关注"),t("strong",[v._v("服务的稳定与安全")])]),v._v(" "),t("li",[v._v("需要考量服务器所能承载的最大用户并发数，需要关注"),t("strong",[v._v("并发性能")])]),v._v(" "),t("li",[v._v("在并发即将达到阈值时，又需要考量平行"),t("strong",[v._v("扩容方案")])]),v._v(" "),t("li",[v._v("为了用户体验，做到极致的接口响应时间，需要充分做好服务的"),t("strong",[v._v("性能优化")])])])])]),v._v(" "),t("h3",{attrs:{id:"问题调试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#问题调试"}},[v._v("#")]),v._v(" 问题调试")]),v._v(" "),t("ul",[t("li",[v._v("前端工程化由于其运行于本地，因此调试时借助 console.log 打印日志进行调试，而这影响的也是个人或者说其实是通用的，这种打印也对工具影响不大")]),v._v(" "),t("li",[v._v("后端服务应用时，由于其运行于服务端，需要综合考虑问题调试时的场景，因此需要考虑用一些方法来进行问题调试和定位策略\n"),t("ul",[t("li",[v._v("不同的业务场景，需要衡量对哪些关键逻辑或者数据打印日志信息，因此需要 Node.js 日志服务模块")]),v._v(" "),t("li",[v._v("而这类日志服务又不能影响性能，因此需要考虑一些"),t("strong",[v._v("高性能日志打印工具")])]),v._v(" "),t("li",[v._v("服务端运行是可能会遇到内存泄漏、句柄泄漏或者进程异常退出等问题，因此这里就需要这类工具和方法来分析定位现网问题")])])])]),v._v(" "),t("h3",{attrs:{id:"关注点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关注点"}},[v._v("#")]),v._v(" 关注点")]),v._v(" "),t("p",[v._v("通过上面的分析，可以发现由于两者所关注的着重点不同，导致两者存在极大的差异性，因此需要在对 Node.js 进行学习的时候进行一些"),t("strong",[v._v("思维转变")]),v._v("，不要片面的通过前端工程化的角度去了解学习，而是应该前后端两者结合，即前端工程化着重于开发效率的提升和研发质量的保证，后端服务则是真正发挥出了 Node.js 的异步驱动特性。因为异步驱动特性，在主线程不被 CPU 密集型所影响时，可以真正发挥出 Node.js 高并发特性，可以作为大部分网络 I/O 较高的后端服务。")])])}),[],!1,null,null,null);_.default=r.exports}}]);