# 前端路由原理

## hash

* hash 变化会触发网页跳转，即浏览器前进和后退
* hash 变化不会触发页面的刷新，SPA 必须的特点
* hash 永远不会提交到后台 server 端

```html

<!-- 创建文件 index.html -->

<body>
    <p>hash test</p>
    <button id="btn1">修改 hash</button>

    <script>
        // hash 的变化如下：
        // 1. JS 修改 url
        // 2. 手动修改 url 的 hash
        // 3. 浏览器的前进和后退
        window.onhashchange = (e) => {
            // 点击事件触发
            console.log('old url', e.oldUrl) // http:0.0.0.0:8080/index.html
            console.log('new url', e.newUrl) // http:0.0.0.0:8080/index.html#/user
            console.log('hash', localtion.hash) // #/user
        }
        // 页面初次加载，获取 hash
        document.addEventerListener('DOMContentLoaded', () => {
            console.log('hash', localtion.hash) // hash 打印为空
        })
        // JS修改 url
        document.getElementById('btn1').addEventerListener('click', () => {
            localtion.href = '#/user'
        })
    </script>
</body>
```

## H5 history

* 用 url 规范的路由，但跳转时不刷新页面
* history.pushState
* window.onpopstate，监听浏览器的前进后退
* 需要后端配合

> 将常规的浏览器路由改造成 H5 history
>
> https://github.com/xxx/yyy 改造

```html
<body>
    <p>history test</p>
    <button id="btn1">修改 hash</button>

    <script>
        // 页面初次加载，获取 path
        document.addEventerListener('DOMContentLoaded', () => {
            console.log('hash', localtion.pathname) // /index.html
        })

        // 打开一个新路由
        // 用 history.pushState，浏览器不会刷新页面
        document.getElementById('btn1').addEventerListener('click', () => {
            // 点击事件触发后打印

            const state = { name: 'page1' }
            console.log('切换路由, page1') // 切换路由, page1
            history.pushState(state, '', 'page1')
        })

        // 监听浏览器的前进后退
        window.onpopstate = (e) => {
            console.log('onpopstate', e.state, localtion.pathname)
            // 后退 onpopstate, null, /index.html
            // 前进 onpopstate, { name: 'page1' }, /page1
        }
    </script>
</body>
```
