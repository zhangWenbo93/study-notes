# 设计原则

## 一、 何为设计

1. 描述<br>
    (1)按照哪一种思路或者标准来实现功能<br>
    (2)功能相同，可以有不同设计方案实现<br>
    (3)伴随需求增加，设计的作用才能体现出来<br>
    (4)前期设计不正确可能导致后期需求变更修改繁琐，改动难度上升，甚至可能重构

2. 结合《UNIX/LINUX设计哲学》<br>
    (1)准则1：小即是美<br>
    (2)准则2：让每个程序只做好一件事<br>
    (3)准则3：快速建立原型<br>
    (4)准则4：舍弃高效率而取可移植性<br>
    (5)准则5：采用纯文本来存储数据<br>
    (6)准则6：充分利用软件的杠杆效应（即软件的可复用性）<br>
    (7)准则7：使用shell脚本来提高杠杆效应和可移植性<br>
    (8)准则8：避免强制性的用户界面（用户界面和系统分开）<br>
    (9)准则9：让每个程序都成为过滤器<br>
    例：ls | grep '.json' | grep 'package'<br>
    这个程序输入ls通过|可以过滤到grep<br>

    --- 小准则 ---

    (1)小准则：允许用户定制环境<br>
    (2)小准则：尽量使操作内核小而轻量化<br>
    (3)小准则：使用小写字母并尽量简写<br>
    (4)小准则：沉默是金（有值输出值，没值或者值不对等输出默认输出值）<br>

    例：<br>
    ls | grep '.json' | grep 'package1'
    执行完这个指令命令行什么都没输出，这就是沉默是金
    然后ls | grep '.json' | grep 'package1' | wc -l结果就是0

    假如ls | grep '.json' | grep 'package1'执行完输出了"no file",然后执行ls | grep '.json' | grep 'package1' | wc -l结果就是1，这显然是不对的<br>
    (5)小准则：各部分之和大于整体<br>
    (6)小准则：寻求90%的解决方案<br>

## 二、五大设计原则（SOLID）

1. S-单一职责原则<br>
    1.1 一个程序只做好一件事<br>
    1.2 如果功能过于复杂就拆分开，每个部分保持独立<br>

2. O-开放封闭原则<br>
    2.1 对扩展开放，对修改封闭<br>
    2.2 增加需求时，扩展新代码，而非修改已有代码<br>
    2.3 软件设计的终极目标<br>

3. L-李氏置换原则<br>
    3.1 子类能覆盖父类<br>
    3.2 所有父类能出现的地方，子类都能出现<br>
    3.3 JS使用较少（弱类型 & 继承使用较少）<br>

4. I-接口独立原则<br>
    4.1 保持接口的单一独立，避免出现“胖接口”<br>
    4.2 JS中没有接口（TS除外），使用较少<br>
    4.3 类似于接口单一原则，这里更关注接口<br>

5. D-依赖导致原则<br>
    5.1 面向接口编程，依赖于抽象而不依赖于具体<br>
    5.2 使用方只关注接口而不关注具体类的实现<br>
    5.3 JS使用较少（没有借口 & 弱类型）<br>

## 三、从设计到模式

1. 设计
2. 模式
3. 分开
4. 从设计到模式

## 四、介绍23种设计模式

1. 创建型<br>
    1.1 工厂模式（工厂方法模式、抽象工厂模式、建造者模式）---对象怎么创建出来，怎么生成<br>
    1.2 单例模式<br>
    1.3 原型模式<br>

2. 组合型<br>
    2.1 适配器模式<br>
    2.2 装饰器模式<br>
    2.3 代理模式<br>
    2.4 外观模式<br>
    2.5 桥接模式<br>
    2.6 组合模式<br>
    2.7 享元模式<br>

3. 行为性<br>
   3.1 策略模式<br>
   3.2 模板方法模式<br>
   3.3 观察者模式<br>
   3.4 迭代器模式<br>
   3.5 职责链模式<br>
   3.6 命令模式<br>
   3.7 备忘录模式<br>
   3.8 状态模式<br>
   3.9 访问者模式<br>
   3.10 中介者模式<br>
   3.11 解释器模式<br>

## 五、如何学习设计模式

1. 明白每个设计的道理和用意
2. 通过经典应用案例体会它的使用场景
3. 自己编码时多思考，多模仿
