# Web 安全威胁解析

## Web 安全攻击概述

#### Web 应用的概念

Web 应用是由动态脚本、编译过的代码等组合而成的，它通常都是架设在 Web 服务器上，用户在 Web 浏览器上发送请求，这些请求使用 HTTP 协议，由 Web 应用和后台服务的数据库及其他动态内容通信。

典型的Web应用是三层架构模型：Web层（View）、业务逻辑层（Controller、Service）、数据层（Model）。而发生 Web 安全问题一般出现在 Web 层和业务逻辑层的中间，因为 Web 层和业务逻辑层是发起请求的层。当 Web 安全出现了漏洞，就会在发起 HTTP 请求的过程中导致某些参数和内容发生错误，就会产生 Web 安全的问题。

![图示](./img/58.png)

#### 常见的一些安全隐患

- 身份认证：攻击者通过错误使用程序的身份认证和会话管理功能，比如：攻击者伪造 Cookie 发送给服务器，从而绕过身份认证
- SQL 注入：攻击者将不受信任的数据作为命令或查询的一部分发送给服务器会产生 SQL 注入攻击，导致数据库的数据泄露了
- 安全配置错误：比如没有配置 HTTPS、或者 HTTPS 证书过期等等
- 跨站脚本攻击：XSS（跨站脚本）让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话或将用户重定向到恶意站点
- 使用了含有漏洞的第三方库
- 不足的日志记录和监控，使得服务器无法感知到攻击

## 验证机制安全

验证机制是 Web 应用程序中最简单的一种安全机制。一般来说，应用程序必须核实用户提交的用户名和密码是否正确，正确则允许其登录，否则禁止登录。

验证机制是整个 Web 应用中最外层的机制，是应用程序防御恶意攻击的核心机制，由于它处在安全防御的最前沿，如果其被轻易突破，通常应用程序的全部功能、数据都会被控制。

#### 典型的身份验证模式

![图示](./img/59.png)

#### 常见的验证技术

- 基于 HTML 表单的验证
- 多元机制，如组合型密码
- 客户端 ssl 证书

但在 Web 应用中使用对多的还是基于 HTML 表单的验证，但是这其中也存在着一些漏洞：

- 弱密码

    许多 Web 应用程序并没有或者很少对用户密码强度进行控制，比如非常短或者空白密码、以常用字典词汇位密码（123456）、密码会用户名完全相同、长时间使用默认密码等

- 暴力破解

    登录功能的公开性会诱使攻击者视图猜测用户名和密码，从而获得访问程序的权力。如果应用程序允许攻击者使用不同的密码暴力尝试，直到找到争取的密码，那这个程序就非常容易遭受攻击，一旦程序容易被暴力破解，那么安全性就大大降低。

    因此，为了防止应用程序被暴力破解，最常见的安全措施就是：<br>
    **验证码技术**，但是在使用时也需要注意几个问题：<br>
    1.验证码是否真实有效<br>
    2.验证码复杂度<br>
    **双因子认证**，核心是通过**个人密码+手机**来达到双重认证效果。<br>

- 忘记密码

    除了登录模块之外，还有另外一个模块---**忘记密码模块**，目前很多网站都提供了这个功能，而这个功能也存在着一些典型的安全问题。

    如果不考虑客服找回的情况，通常会有三种方式认证用户：用户设定的安全问题、在注册时留下的邮箱、给预留手机号发送验证短信。

## 会话管理机制

在绝大多数的 Web 应用程序中，会话管理机制是一个基本的安全组件，它和验证机制有类似的地方，但它又在验证机制之后， 它在应用程序执行登陆的过程中也是重要的一个环节，因为它可以在用户通过请求提交他们的证书后，持续向应用程序保证任何特定用户身份的真实性。

由于大部分的会话令牌是通过用户的用户名或者邮箱等信息进行编码或者模糊处理生成的，实际上是不太安全的，因此容易产生漏洞，比如令牌可被预测（包含隐含序列或者时间依赖的令牌）、令牌的随机数看似随机，其实其随机强度并不高， 从而被攻击。

会话在传输中也有漏洞，比如会话终止攻击，会话劫持攻击（通过网络嗅探、XSS攻击等方式获取用户会话令牌）。

> 如何进行防御？

1. 令牌传输安全
   - 令牌只能通过 HTTPS 传送
   - 如果适应 HTTP Cookie 传送令牌（大多数情况），应将这些 Cookie 标记为 **secure**，以防止用户浏览器通过 HTTP 传送它们。
2. 增加软硬会话过期
   - 软会话过期：用户在一定时间没有与应用系统交互，则会话过期，服务端清空 Session（Session失效）
   - 硬会话过期：用户登录到系统一段时间，不管用户做什么，该会话都会过期
3. 提供完善的注销功能
   - 用户可手动使会话过期（网站的退出功能）
   - TIPS：要保证注销不存在会话终止漏洞

## SQL 注入攻击

目前几乎每个 web 应用都需要适应数据库来保存操作所需要的各种信息，因此经常会建立用户提交数据的 SQL 语句，如果建立这种语句的方法不安全，那么就容易遭到 SQL 注入攻击。

例如：在登录过程中，在用户名输出入 or 1=1，即便密码输入错误，最后也会登录成功，这是因为如果我们的SQL语句是：select * from user where username = ‘用户名’ and password = ‘密码’，那么当我们输入or 1 = 1后，语句就变成select * from user where username = ‘’ or 1 = 1 and password = ‘密码’，就变成恒等于了，所以攻击者就能登录成功了， SQL注入成功后，数据库的数据就非常不安全了。

#### SQL 注入危害

1. 弹指数据库的具体结构，为进一步攻击做准备
2. 泄露数据，尤其是机密信息、账户信息等
3. 取得更高权限，来修改表数据甚至是内部结构

#### 注入防御

参数化查询：对 SQL 注入最根本性的防御策略（预处理语句）

- 指定查询结构，用户输入预留占位符
- 指定占位符内容

## XSS 攻击（跨站脚本攻击）

XSS 是一种经常出现在 web 应用中的计算机安全漏洞，它允许恶意 web 用户将代码植入到提供给其他用户使用的页面中，其他用户在观看网页时，恶意脚本就会执行，这类攻击通常用注入 HTML 或 JS 等脚本发动攻击， 攻击成功后，攻击者可以获取用户的 Cookie 等私密信息。

#### 攻击危害

1. 盗取各类用户账号，如机器登录账号、用户网银账号、各类管理员账号
2. 控制数据，包括读取、篡改、添加、删除敏感数据的能力
3. 盗取有价值的商业资料
4. 非法转账
5. 控制受害机器向其他网站发起攻击

#### XSS 分类

针对 XSS 的攻击方式不同，可以分为三大类：

1. 反射式 XSS

    反射式 XSS 也称为 非永久性 XSS，是当前最流行的 XSS 攻击，它出现在服务器直接使用客户端提交的数据，如 url 的数据， html 表单中提交的数据等，并且没有对数据进行无害化处理，如果提交的数据中含有 html 控制字符而没有被正确处理，那么一个简单的 XSS 攻击就会发生。

    典型的反射式攻击可通过一个邮件或中间网站，诱饵是一个看起来可信任的站点链接，其中包含 XSS 攻击脚本，如果没有正确处理，点击之后就会导致浏览器执行恶意攻击脚本。

2. 存储式 XSS

    存储式 XSS 也称为 永久性 XSS，危害极大，容易被发现，攻击者将攻击脚本上传到 web 服务器上，使得所有的访问该页面的用户都面临着信息泄露的可能，其中也包括 web 服务器的管理员。

    存储式 XSS 多发生在最终显示给其他用户的位置包含：个人信息字段，文档、上传文件及其它数据名称，提交给应用程度管理员的反馈或问题，用户之间共享的上传文件内容等。

3. 基于 DOM 的 XSS

    基于 DOM 的 XSS 攻击仅通过 JavaScript 的方式执行，也就是说这种攻击常发生在应用程序每次返回相同的静态 html，而通过客户端 JavaScript 动态生成的信息，并不会跟服务端产生交互获取的时候。

#### XSS 攻击载荷

载荷就是说到底要攻击哪里，会有以下几个目标：

1. 会话令牌

    - XSS 攻击最普遍的方式
    - 截取一名受害者的会话令牌，劫持他的会话，进而作为受害者的身份来使用程序，执行任意操作并占有该用户的账户。

2. 虚拟置换

    - 这种攻击需要在一个 web 应用程序页面恶意注入数据，从而向应用程序的用户传递误导信息，包括简单的向站点注入 html 或者使用脚本注入精心设计的内容
    - 攻击者实际上没有修改保存在服务器上的内容，而是利用程序处理并显示用户提交的输入方面的缺陷实现置换。

3. 注入木马

   - 这种攻击造成的后果远比虚拟置换严重，它在易受攻击的应用程序中注入实际运行的功能，意在欺骗终端用户执行某种有害的操作，随后将它们传送给攻击者
   - 在一个明显的攻击中，攻击者注入的功能向用户显示一个木马登录表单，要求他们向攻击者控制的服务器提交他们自己的证书

#### 防御措施

1. 输入验证

    服务器对用户提交的数据应该进行严格的确认：数据格式、数据长度、是否包含非法字符、设置数据输入规则

2. 输出编码

   HTML 编码适应对应的 HTML 实体替代字面量字符。这样做可以确保浏览器安全处理可能为恶意的字符，把它们当做 HTML 文档的内容处理而非结构处理。

   即便用户输入了XSS脚本，但是经过编码后，XSS脚本就会被净化，不会被浏览器当做脚本执行

在这两种防御中，**输出确认最为重要**，必不可少。实施**严格的输入确认**应被视为一种次要故障恢复。

## CSRF 攻击

CSRF （跨站请求伪造），是一种对网站的恶意利用，尽管听起来很像跨站脚本（XSS），但它与 XSS 非常不同，并且攻击方式几乎相左。

XSS 利用站点内的信任用户（受害者），而 CSRF 通过伪装来自受信任用户的请求来利用受信任的网站且 CSRF 的破坏力依赖于受害者的权限，因此相对较而言，CSRF 攻击往往不太流行和难以防范。

比如：用户A登录了一个银行的网站，浏览器保存着A的 Cookie，此时，A又打开一个标签页访问其他的网站，一旦A点击了攻击者的网站，而攻击者也指向了这个银行网站而让A感知不到，那么攻击者就会调用A的浏览器中的 Cookie 去成功访问银行网站，进行转账。

> 如何预防？

- **增加一些确认操作**，弹框提示操作内容
- **重新认证**，比如：当进行转账等敏感操作时，要求重新输入密码。
- **使用 Token**，比如：登录时产生一个不可预知的 CSRF token，并且存放在用户 session 中，每次请求校验服务端的 Token 和 客户端提交的 session 中的 Token 是否一致。
