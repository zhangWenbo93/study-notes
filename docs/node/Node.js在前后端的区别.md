# Node.js在前后端的区别

## Node.js 从工程化工具到后端服务应用的转变和区别

Node.js 不仅可以用来做前端的工程化，比如：利用 webpack 提升前端开发效率以及保证开发质量、 SSR 的实现以及前端的一些工具化场景，也可以用来做部分后端开发，因为它的一些优点，比如：高并发特性以及研发高效能。

但其实前端应用的最终目的都是为了**提升前端研发效率或者保证研发质量**，并没有真正的使用到 Node.js 核心特点。而后端服务应用才是真正地应用 Node.js 异步事件驱动的特性。

下面的会从以下几个方面分析两者的区别

| 差异点 | 说明 | 前端应用 | 后端应用 |
| ---- | -----| -----| -----|
| 运行环境 | Node.js运行在何处 | 运行在本地 | 运行在远程服务器 |
| 受众用户 | 启用的服务，受众用户 | 服务于本地开发 | 服务真实用户 |
| 问题调试 | 定位问题对比 | 调试简单 | 复杂，需要日志埋点 |
| 关注点 | 着重解决的问题 | 提升研发效率、质量 | 保证安全、稳定性 |

### 运行环境

* 前端工程化大部分情况都是依赖于当前开发环境，运行在本地开发机器，可以快速判断定位、分析解决问题
* 后端服务基本都是运行于远程服务器上，需要依赖于一些工具分析判断或者监控其运行情况

> 那么因为运行环境的差异，由此会引发那些不同呢？

* 需要应用工具将服务发布到远程机器上，这里就涉及 **devops 工具**
* 需要保证远程服务的安全与稳定，这就涉及一些进程管理工具，例如我们常见的 **PM2**
* 需要判断远程服务运行是否正常，这就涉及远程服务的**监控和告警机制**
* 需要通过远程日志来定位分析问题，这就涉及日**志打印和跟踪染色**

### 受众用户

* 前端工程化一般都是服务于开发者，比如 Webpack 打包或者将 ES6、ES7 转为 ES5 语法等，都是基于开发者工具，服务于开发者
* 后端服务应用则服务于真实的用户群体，为用户提供各种交互体验方面的数据处理等

> 那么因为受众用户的差异，由此会引发那些不同呢？

* 前端工程化侧重于为开发者**提升研发效率或者研发质量**
* 后端服务应用则侧重点更多，比如：
  * 由于是基于用户发送的内容，用户有时候发送一些非法或者违法的内容，因此必须关注**服务的稳定与安全**
  * 需要考量服务器所能承载的最大用户并发数，需要关注**并发性能**
  * 在并发即将达到阈值时，又需要考量平行**扩容方案**
  * 为了用户体验，做到极致的接口响应时间，需要充分做好服务的**性能优化**

### 问题调试

* 前端工程化由于其运行于本地，因此调试时借助 console.log 打印日志进行调试，而这影响的也是个人或者说其实是通用的，这种打印也对工具影响不大
* 后端服务应用时，由于其运行于服务端，需要综合考虑问题调试时的场景，因此需要考虑用一些方法来进行问题调试和定位策略
  * 不同的业务场景，需要衡量对哪些关键逻辑或者数据打印日志信息，因此需要 Node.js 日志服务模块
  * 而这类日志服务又不能影响性能，因此需要考虑一些**高性能日志打印工具**
  * 服务端运行是可能会遇到内存泄漏、句柄泄漏或者进程异常退出等问题，因此这里就需要这类工具和方法来分析定位现网问题

### 关注点

通过上面的分析，可以发现由于两者所关注的着重点不同，导致两者存在极大的差异性，因此需要在对 Node.js 进行学习的时候进行一些**思维转变**，不要片面的通过前端工程化的角度去了解学习，而是应该前后端两者结合，即前端工程化着重于开发效率的提升和研发质量的保证，后端服务则是真正发挥出了 Node.js 的异步驱动特性。因为异步驱动特性，在主线程不被 CPU 密集型所影响时，可以真正发挥出 Node.js 高并发特性，可以作为大部分网络 I/O 较高的后端服务。
